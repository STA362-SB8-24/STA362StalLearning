{
  "hash": "a0fdb90f9979d8dc5b0ddb3e4d65c1f9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Chapter 8 Part 1\"\nsubtitle: \"Basics of Decision Trees\"\nformat: \n  revealjs:\n    output-file: \"07-basic-dt.html\"\n    slide-number: true\n  html:\n    output-file: \"07-basic-dt_o.html\"\neditor_options: \n  chunk_output_type: console\nlogo: \"img/icon.png\"\n---\n\n\n\n## Setup\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(ISLR2)\nlibrary(rpart.plot)\n#install.packages('rpart.plot')\n```\n:::\n\n\n## Decision trees {.smaller}\n\n* Can be applied to **regression** problems\n* Can be applied to **classification** problems\n\n. . .\n\n::: question\nWhat is the difference?\n:::\n\n# Regression trees\n\n\n## Decision tree - Baseball Salary Example {.smaller}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](07-basic-dt_files/figure-revealjs/unnamed-chunk-2-1.png){width=960}\n:::\n:::\n\n\n\n\n::: question\nHow would you stratify this?\n:::\n\n\n\n## Decision tree - Baseball Salary Example\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](07-basic-dt_files/figure-revealjs/unnamed-chunk-3-1.png){width=960}\n:::\n:::\n\n\n\n\n## Let's walk through the figure {.smaller}\n\n* This is using the `Hitters` data from the `ISLR` ðŸ“¦\n* I fit a **regression tree** predicting the salary of a baseball player from:\n  * Number of years they played in the major leagues\n  * Number of hits they made in the previous year\n\n* At each **node** the label (e.g., $X_j < t_k$ ) indicates that the _left_ branch that comes from that split. The _right_ branch is the opposite, e.g. $X_j \\geq t_k$.\n\n## Let's walk through the figure {.smaller}\n\n* For example, the first **internal node** indicates that those to the left have less than 4.5 years in the major league, on the right have $\\geq$ 4.5 years.\n\n\n* The number on the _top_ of the **nodes** indicates the predicted Salary, for example before doing _any_ splitting, the average Salary for the whole dataset is 536 thousand dollars.\n\n\n* This tree has **two internal nodes** and **three termninal nodes**\n\n\n\n## Decision tree - Baseball Salary Example {.smaller}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](07-basic-dt_files/figure-revealjs/unnamed-chunk-4-1.png){width=960}\n:::\n:::\n\n\n\n\n## Decision tree - Baseball Salary Example {.smaller}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](07-basic-dt_files/figure-revealjs/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\n\n\n## Decision tree - Baseball Salary Example {.smaller}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](07-basic-dt_files/figure-revealjs/unnamed-chunk-6-1.png){width=960}\n:::\n:::\n\n\n\n\n## Decision tree - Baseball Salary Example {.smaller}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](07-basic-dt_files/figure-revealjs/unnamed-chunk-7-1.png){width=960}\n:::\n:::\n\n\n\n\n## Terminology {.smaller}\n\n* ðŸŒ² The final regions, $R_1, R_2, R_3$ are called **terminal nodes**\n* ðŸŽ‹ You can think of the trees as _upside down_, the **leaves** are at the bottom\n* ðŸŒ´ The splits are called **internal nodes**\n\n\n\n## Interpretation of results {.smaller}\n\n* `Years` is the most important factor in determining `Salary`; players with less experience earn lower salaries\n\n\n* Given that a player is less experienced, the number of `Hits` seems to play little role in the `Salary`\n\n\n* Among players who have been in the major leagues for 4.5 years or more, the number of `Hits` made in the previous year **does** affect `Salary`, players with more `Hits` tend to have higher salaries\n\n\n* This is probably an oversimplification, but see how easy it is to interpret!\n\n\n\n\n\n\n## <i class=\"fas fa-edit\"></i> `Interpreting decision trees`  {.smaller}\n\n:::{.panel-tabset}\n\n### Questions\n\n::: nonincremental\n\n1. How many internal nodes does this plot have? How many terminal nodes?\n2. What is the average Salary for players who have more than 6.5 years in the major leagues but less than 118 Hits? What % of the dataset fall in this category?\n\n:::\n\n### Graph\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](07-basic-dt_files/figure-revealjs/unnamed-chunk-8-1.png){width=960}\n:::\n:::\n\n\n:::\n\n## The tree building process {.smaller}\n\n* Divide the predictor space (the set of possible values for $X_1, X_2, \\dots, X_p$ ) into $J$ distinct non-overlapping regions, $R_1, R_2, \\dots R_j$\n* For every observation that falls into the region $R_j$, we make the same prediction, the **mean response value** for the training observations in $R_j$\n\n\n\n## The tree building process {.smaller}\n\n* The regions could have any shape, but we choose to divide the predictor space into high-dimensional **boxes** for simplicity and ease of interpretation\n\n* The goal is to find boxes, $R_1, \\dots, R_j$ that minimize the RSS, given by\n\n* $\\sum_{j=1}^J\\sum_{i\\in R_j}(y_i-\\hat{y}_{R_j})^2$ where $\\hat{y}_{R_j}$ is the mean response for the training observations within the $j$th box.\n\n\n\n## The tree building process {.smaller}\n\n* It is often computationally infeasible to consider every possible partition of the feature space into $J$ boxes\n* Therefore, we take a **top-down, greedy** approach known as recursive binary splitting\n\n* This is **top-down** because it begins at the top of the tree and then splits the predictor space successively into two branches at a time\n\n\n* It is **greedy** because at each step the **best** split is made at that step (instead of looking forward and picking a split that may result in a better tree in a future step)\n\n\n\n## The tree building process {.smaller}\n\n* First select the predictor $X_j$ and the cutpoint $s$ such that splitting the predictor space into $\\{X|X_j < s\\}$ and $\\{X|X_k\\geq s\\}$ leads to the _greatest possible reduction in RSS_\n\n\n* We repeat this process, looking for the best predictor and cutpoint to split the data within each of the resulting regions\n\n* Now instead of splitting the _entire_ predictor space, we split one of the two previously identified regions, now we have _three_ regions\n\n\n## The tree building process {.smaller}\n\n* Then we look to split one of these three regions to minimize the RSS\n* This process continues until some stopping criteria are met. \nðŸ›‘ e.g., we could stop when we have created a fixed number of regions, or we could keep going until no region contains more than 5 observations, etc.\n\n\n\n## <i class=\"fas fa-edit\"></i> `Draw a partition`\n\nDraw an example of a partition of a two-dimensional feature space that could result from recursive binary splitting with six regions. Label your figure with the regions, $R_1, \\dots, R_6$ as well as the cutpoints $t_1, t_2, \\dots$. Draw a decision tree corresponding to this partition. \n\n\n## Decision tree predictions {.smaller}\n\n* Predict the response for a _test observation_ using the mean of the _training observations_ in the region that the _test observation_ belongs to\n\n. . .\n\n::: question\nWhat could potentially go wrong with what we have described so far?\n:::\n\n\n* The process may produce good predictions on the _training_ set but is likely to **overfit!**\n\n\n\n## Pruning a tree {.smaller}\n\n_Do you love the tree puns? I DO!_\n\n* A smaller tree (with fewer splits, that is fewer regions $R_1,\\dots, R_j$ ) may lead to **lower variance** and better interpretation at the cost of a little **bias**\n\n\n* A good strategy is to _grow_ a very large tree, $T_0$, and then **prune** it back to obtain a **subtree**\n\n\n* For this, we use **cost complexity pruning** (also known as **weakest link** ðŸ”— **pruning**)\n\n\n* Consider a sequence of trees indexed by a nonnegative tuning parameter, $\\alpha$. For each $\\alpha$ there is a subtree $T \\subset T_0$ such that $\\sum_{m=1}^{|T|}\\sum_{i:x_i\\in R_m}(y_i-\\hat{y}_{R_m})^2+\\alpha|T|$ is as small as possible. \n\n\n\n## Pruning {.smaller}\n\n$$\\sum_{m=1}^{|T|}\\sum_{i:x_i\\in R_m}(y_i-\\hat{y}_{R_m})^2+\\alpha|T|$$\n\n* $|T|$ indicates the number of terminal nodes of the tree $T$\n\n\n* $R_m$ is the box (the subset of the predictor space) corresponding to the $m$th terminal node\n\n\n* $\\hat{y}_{R_m}$ is the mean of the training observations in $R_m$\n\n\n\n## Choosing the best subtree {.smaller}\n\nThe _tuning parameter_, $\\alpha$, controls the trade-off between the subtree's _complexity_ and its _fit_ to the training data\n\n\n::: question\nHow do you think you could select $\\alpha$?\n:::\n\n\n* You can select an optimal value, $\\hat{\\alpha}$ using **cross-validation**!\n\n\n* Then return to the full dataset and obtain the subtree using $\\hat{\\alpha}$\n\n\n\n## Summary regression tree algorithm {.smaller}\n\n* Use **recursive binary splitting** to grow a large tree on the training data, stop when you reach some stopping criteria\n\n\n* Apply **cost complexity pruning** to the larger tree to obtain a sequence of best subtrees, as a function of $\\alpha$\n\n\n* Use K-fold cross-validation to choose $\\alpha$. Pick $\\alpha$ to minimize the average error\n\n\n* Return the subtree that corresponds to the chosen $\\alpha$ \n\n\n# The baseball example\n\n\n\n## 1. Randomly divide the data in half, 132 training observations, 131 testing {.smaller}\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(77)\nbaseball_split <- initial_split(baseball, prop = 0.5)\nbaseball_train <- training(baseball_split)\n```\n:::\n\n\n\n\n## 2. Create cross-validation object for 6-fold cross validation {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaseball_cv <- vfold_cv(baseball_train, v = 6)\n```\n:::\n\n\n\n\n## 3. Create a model specification that tunes based on complexity, $\\alpha$ and add to workflow {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree_spec <- decision_tree(\n  cost_complexity = tune(), \n  tree_depth = 10,\n  mode = \"regression\") |>\n  set_engine(\"rpart\")\n\nwf <- workflow() |>\n  add_recipe(\n    recipe(Salary ~ Hits + Years + PutOuts + RBI + Walks + Runs, data = baseball)\n    ) |>\n  add_model(tree_spec)\n```\n:::\n\n\n\n\n::: question\nWhat is my tree depth for my \"large\" tree?\n:::\n\n\n\n## 4. Fit the model on the cross validation set {.smaller}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid <- expand_grid(cost_complexity = seq(0.01, 0.05, by = 0.01))\nmodel <- tune_grid(wf,\n                   grid = grid,\n                   resamples = baseball_cv)\n```\n:::\n\n\n\n\n\n::: question\nWhat $\\alpha$s am I trying?\n:::\n\n\n\n## 5. Choose $\\alpha$ that minimizes the RMSE {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel |>\n  show_best(metric = \"rmse\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 7\n  cost_complexity .metric .estimator  mean     n std_err .config             \n            <dbl> <chr>   <chr>      <dbl> <int>   <dbl> <chr>               \n1            0.01 rmse    standard    422.     6    33.6 Preprocessor1_Model1\n2            0.02 rmse    standard    423.     6    32.0 Preprocessor1_Model2\n3            0.03 rmse    standard    425.     6    31.9 Preprocessor1_Model3\n4            0.04 rmse    standard    429.     6    32.5 Preprocessor1_Model4\n5            0.05 rmse    standard    441.     6    25.3 Preprocessor1_Model5\n```\n\n\n:::\n:::\n\n\n\n\n## 5. Choose $\\alpha$ that minimizes the RMSE {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel |>\n  show_best()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel |>\n  select_best(metric = \"rmse\") #<<\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 Ã— 2\n  cost_complexity .config             \n            <dbl> <chr>               \n1            0.01 Preprocessor1_Model1\n```\n\n\n:::\n:::\n\n\n\n\n## 5. Choose $\\alpha$ that minimizes the RMSE {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel |>\n  show_best(metric = \"rmse\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_complexity <- select_best(model, metric = \"rmse\")\n```\n:::\n\n\n\n\n## 6. Fit the final model {.smaller}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwf_final <- wf |>\n  finalize_workflow(final_complexity)\n\nfinal_model <- fit(wf_final,\n                   data = baseball_train)\n```\n:::\n\n\n\n\n\n## Final tree\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrpart.plot::rpart.plot(final_model$fit$fit$fit, roundint = FALSE)\n```\n\n::: {.cell-output-display}\n![](07-basic-dt_files/figure-revealjs/unnamed-chunk-20-1.png){width=960}\n:::\n:::\n\n\n\n\n::: question\nHow many terminal nodes does this tree have?\n:::\n\n\n\n## Calculate RMSE on the test data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaseball_test <- testing(baseball_split)\nfinal_model |>\n  predict(new_data = baseball_test) |>\n  bind_cols(baseball_test) |>\n  metrics(truth = Salary, estimate = .pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rmse    standard     380.   \n2 rsq     standard       0.291\n3 mae     standard     248.   \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## <i class=\"fas fa-laptop\"></i> `Application Exercise`\n\nUsing the `College` data from the `ISLR` package, predict the number of applications received from a subset of the variables of your choice using a decision tree. (Not sure about the variables? Run `?College` in the console after loading the `ISLR` package)\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}